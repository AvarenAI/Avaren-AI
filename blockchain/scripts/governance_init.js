const { Connection, clusterApiUrl, Keypair, LAMPORTS_PER_SOL } = require('@solana/web3.js');
const { AnchorProvider, Program, setProvider, getProvider } = require('@project-serum/anchor');
const { readFileSync } = require('fs');
const { join } = require('path');
const dotenv = require('dotenv');

// Load environment variables from .env file if available
dotenv.config();

// Configuration
const CLUSTER = process.env.CLUSTER || 'devnet'; // Options: 'mainnet-beta', 'testnet', 'devnet'
const WALLET_PATH = process.env.WALLET_PATH || join(__dirname, 'wallet.json'); // Path to admin wallet keypair
const PROGRAM_ID = process.env.PROGRAM_ID || 'YourProgramIdHere'; // Replace with actual program ID after deployment
const REALM_NAME = process.env.REALM_NAME || 'OntoraGovernance'; // Name of the governance realm
const MIN_VOTING_POWER = process.env.MIN_VOTING_POWER || 1; // Minimum tokens required to vote
const VOTING_PERIOD_SECONDS = process.env.VOTING_PERIOD_SECONDS || 604800; // Voting period in seconds (default: 7 days)
const QUORUM_PERCENT = process.env.QUORUM_PERCENT || 60; // Quorum percentage for proposals to pass
const MAX_VOTING_TIME_SECONDS = process.env.MAX_VOTING_TIME_SECONDS || 1209600; // Max voting time in seconds (default: 14 days)

// Utility to get cluster URL
function getClusterUrl(cluster) {
  switch (cluster) {
    case 'mainnet-beta':
      return clusterApiUrl('mainnet-beta');
    case 'testnet':
      return clusterApiUrl('testnet');
    case 'devnet':
    default:
      return clusterApiUrl('devnet');
  }
}

// Utility to load wallet keypair from file
function loadWalletKeypair(walletPath) {
  try {
    const walletData = JSON.parse(readFileSync(walletPath, 'utf-8'));
    const secretKeyUint8Array = Uint8Array.from(Buffer.from(walletData.secretKey, 'base64'));
    return Keypair.fromSecretKey(secretKeyUint8Array);
  } catch (error) {
    console.error('Failed to load wallet keypair from:', walletPath);
    console.error('Error:', error.message);
    console.error('Ensure the wallet file exists and contains a valid secret key in base64 format.');
    process.exit(1);
  }
}

// Utility to check wallet balance
async function checkWalletBalance(connection, publicKey) {
  try {
    const balance = await connection.getBalance(publicKey, 'confirmed');
    console.log(`Wallet balance for ${publicKey.toString()}:`, balance / LAMPORTS_PER_SOL, 'SOL');
    if (balance < LAMPORTS_PER_SOL / 10) {
      console.warn('Warning: Wallet balance is low. Consider funding the wallet for transaction fees.');
    }
    return balance;
  } catch (error) {
    console.error('Failed to check wallet balance for:', publicKey.toString());
    console.error('Error:', error.message);
    return 0;
  }
}

// Utility to load program IDL (assuming it's generated by Anchor)
function loadProgramIdl(programIdStr) {
  try {
    // This assumes the IDL is available in a local file or fetched dynamically
    // For simplicity, we're using a placeholder. Replace with actual IDL loading logic if needed.
    const idlPath = join(__dirname, '../target/idl/governance.json');
    if (readFileSync(idlPath, 'utf-8')) {
      const idl = JSON.parse(readFileSync(idlPath, 'utf-8'));
      console.log('Loaded program IDL for governance program.');
      return idl;
    } else {
      throw new Error('IDL file not found.');
    }
  } catch (error) {
    console.error('Failed to load program IDL for program ID:', programIdStr);
    console.error('Error:', error.message);
    console.error('Falling back to minimal initialization without full IDL. Replace PROGRAM_ID in script.');
    // Return a minimal placeholder structure for governance initialization
    return {
      name: 'Governance',
      instructions: [
        {
          name: 'initializeRealm',
          accounts: [
            { name: 'realm', type: 'publicKey' },
            { name: 'authority', type: 'publicKey' },
            { name: 'payer', type: 'publicKey' },
            { name: 'systemProgram', type: 'publicKey' },
          ],
          args: [
            { name: 'name', type: 'string' },
            { name: 'minVotingPower', type: 'u64' },
            { name: 'votingPeriod', type: 'u64' },
            { name: 'quorumPercent', type: 'u8' },
            { name: 'maxVotingTime', type: 'u64' },
          ],
        },
      ],
    };
  }
}

// Main function to initialize governance parameters
async function initializeGovernance() {
  console.log(`Initializing governance parameters on ${CLUSTER} cluster...`);

  // Set up connection
  const connection = new Connection(getClusterUrl(CLUSTER), 'confirmed');
  console.log('Connected to cluster:', CLUSTER);

  // Load admin wallet
  const adminKeypair = loadWalletKeypair(WALLET_PATH);
  console.log('Admin wallet loaded. Public key:', adminKeypair.publicKey.toString());

  // Check admin wallet balance
  await checkWalletBalance(connection, adminKeypair.publicKey);

  // Set up Anchor provider
  const provider = new AnchorProvider(connection, { publicKey: adminKeypair.publicKey, signTransaction: async (tx) => tx }, { preflightCommitment: 'confirmed' });
  setProvider(provider);
  console.log('Anchor provider set up for transaction signing.');

  // Load program IDL and initialize program
  const idl = loadProgramIdl(PROGRAM_ID);
  const programId = PROGRAM_ID !== 'YourProgramIdHere' ? PROGRAM_ID : adminKeypair.publicKey; // Fallback for demo
  const program = new Program(idl, programId, provider);
  console.log('Governance program initialized with ID:', programId.toString());

  // Derive or specify realm account (simplified for demo; adjust based on program design)
  const realmKeypair = Keypair.generate(); // In real scenarios, derive PDA for realm
  console.log('Realm account public key (placeholder):', realmKeypair.publicKey.toString());

  // Governance parameters
  const governanceParams = {
    name: REALM_NAME,
    minVotingPower: BigInt(MIN_VOTING_POWER),
    votingPeriod: BigInt(VOTING_PERIOD_SECONDS),
    quorumPercent: parseInt(QUORUM_PERCENT, 10),
    maxVotingTime: BigInt(MAX_VOTING_TIME_SECONDS),
  };
  console.log('Governance parameters to initialize:');
  console.log(`- Realm Name: ${governanceParams.name}`);
  console.log(`- Minimum Voting Power: ${governanceParams.minVotingPower}`);
  console.log(`- Voting Period (seconds): ${governanceParams.votingPeriod}`);
  console.log(`- Quorum Percent: ${governanceParams.quorumPercent}%`);
  console.log(`- Max Voting Time (seconds): ${governanceParams.maxVotingTime}`);

  // Initialize governance realm (adjust accounts and args based on actual program)
  try {
    console.log('Sending transaction to initialize governance realm...');
    const tx = await program.methods
      .initializeRealm(
        governanceParams.name,
        governanceParams.minVotingPower,
        governanceParams.votingPeriod,
        governanceParams.quorumPercent,
        governanceParams.maxVotingTime
      )
      .accounts({
        realm: realmKeypair.publicKey,
        authority: adminKeypair.publicKey,
        payer: adminKeypair.publicKey,
        systemProgram: require('@solana/web3.js').SystemProgram.programId,
      })
      .signers([adminKeypair, realmKeypair])
      .rpc({ commitment: 'confirmed' });

    console.log('Governance realm initialized successfully.');
    console.log('Transaction signature:', tx);
    console.log('Realm public key:', realmKeypair.publicKey.toString());
    console.log('Admin authority:', adminKeypair.publicKey.toString());

    // Additional post-initialization steps (optional)
    console.log('\nPost-initialization summary:');
    console.log('- Governance realm is now active with the specified parameters.');
    console.log('- Authority is set to the admin wallet. Transfer authority if needed.');
    console.log('- Save the realm public key for future interactions (proposals, voting).');
    console.log('- Verify on-chain state using Solana explorer or custom scripts.');
  } catch (error) {
    console.error('Failed to initialize governance realm:');
    console.error('Error:', error.message);
    console.error('Possible causes:');
    console.error('- Insufficient funds in admin wallet for transaction fees or rent.');
    console.error('- Incorrect program ID or IDL mismatch with on-chain program.');
    console.error('- Invalid accounts or parameters for the governance program.');
    console.error('Check cluster connection, wallet balance, and program details, then retry.');
    process.exit(1);
  }

  // Final instructions
  console.log('\nNext steps:');
  console.log('- Use the realm public key to create governance proposals or councils.');
  console.log('- Set up token mints or community tokens if required for voting power.');
  console.log('- Test governance functionality (proposals, voting) before mainnet deployment.');
  console.log('- Document governance parameters and rules for transparency with users.');
}

// Error handling wrapper for async execution
async function main() {
  try {
    await initializeGovernance();
  } catch (error) {
    console.error('Unexpected error during governance initialization:', error.message);
    process.exit(1);
  }
}

// Execute initialization
main().then(() => {
  console.log('Governance initialization script execution completed.');
  process.exit(0);
}).catch((error) => {
  console.error('Governance initialization script failed:', error.message);
  process.exit(1);
});
